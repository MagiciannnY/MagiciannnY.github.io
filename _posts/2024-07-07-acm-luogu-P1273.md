---
layout: post
title: "P1273 有线电视网"
data: 2024-07-07
tags: acm 树状dp 分组背包
comment: true
toc: false
author: Magiciannny
---


原题链接：https://www.luogu.com.cn/problem/P1273

## 题目描述

某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。

从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。

现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。

写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。

## 输入格式

输入文件的第一行包含两个用空格隔开的整数 $N$ 和 $M$，其中 $2 \le N \le 3000$，$1 \le M \le N-1$，$N$ 为整个有线电视网的结点总数，$M$ 为用户终端的数量。

第一个转播站即树的根结点编号为 $1$，其他的转播站编号为 $2$ 到 $N-M$，用户终端编号为 $N-M+1$ 到 $N$。

接下来的 $N-M$ 行每行表示—个转播站的数据，第 $i+1$ 行表示第 $i$ 个转播站的数据，其格式如下：

$K \ \ A_1 \ \ C_1 \ \ A_2 \ \ C_2 \ \ \ldots \ \ A_k \ \ C_k$

$K$ 表示该转播站下接 $K$ 个结点（转播站或用户），每个结点对应一对整数 $A$ 与 $C$ ，$A$ 表示结点编号，$C$ 表示从当前转播站传输信号到结点 $A$ 的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。单次传输成本和用户愿意交的费用均不超过 10。

## 输出格式

输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。

## 样例 #1

### 样例输入 #1

```
5 3
2 2 2 5 3
2 3 2 4 3
3 4 2
```

### 样例输出 #1

```
2
```

## 提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)

如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到 $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。

从结点 ① 可以传送信号到结点 ②，费用为 $2$；

也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；

从结点 ② 可以传输信号到结点 ③，费用为$2$；

也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。

如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用 $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。

---

## 题解

这是一个树形 dp + 分组背包的题。

1. 节点需要存储其子树中有多少用户
2. 记 $dp[i][j]$ 表示节点 $i$ 处选择 $j$ 个用户的最大收益
3. 对于每个转播站节点是一个分组背包问题：
    1. 背包总容量为子树中的用户数量
    2. 节点中的每个子树（以直接儿子为根）视为一组，每组中选择 $k$ 个用户节点
    3. 转移方程为 $dp[u][j]=\max(dp[u][j], dp[u][j-k]+dp[v][k]-cost(u,v))$ 

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3005;
const int M = 0x3f;
typedef long long ll;

int n, m; 
struct edge {
    int v, w;
};
vector<edge> G[N];
int pay[N];
int dp[N][N];

int dfs(int u) {
    if (u >= n - m + 1) { dp[u][1] = pay[u]; return 1; }
    int tot = 0;
    int cnt;
    for (edge& e : G[u]) {
        int v = e.v, w = e.w;
        cnt = dfs(v);
        tot += cnt;
        for (int j = tot;j > 0;j--) {
            for (int k = 1;k <= cnt;k++) {
                if (j >= k) dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k] - w);
            }
        }
    }
    return tot;
}

int main() {
    cin >> n >> m;
    for (int i = 1;i <= n - m;i++) {
        int k; cin >> k;
        for (int j = 1;j <= k;j++) {
            int v, w; cin >> v >> w;
            G[i].push_back({ v,w });
        }
    }
    for (int i = n - m + 1;i <= n;i++) cin >> pay[i];
    memset(dp, ~M, sizeof(dp));
    for (int i = 1;i <= n;i++) dp[i][0] = 0;
    dfs(1);
    for (int i = m;i >= 1;i--) {
        if (dp[1][i] >= 0) { cout << i << '\n'; break; }
    }
    return 0;
}
```

